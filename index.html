<html>
<head>
<title>AudioPlay</title>
</head>
<body>
<div id="keys"></div>
<br>
<input type="range" min="0" max="1" step="0.05" value="0.25" id="volume-input" />
<select id="instrument-input">
    <option value="0">Sine</option>
    <option value="1">Square</option>
    <option value="2">Sawtooth</option>
    <option value="3">Periodic</option>
    <option value="4">Organ</option>
    <option value="5">Piano</option>
    <option value="6">Fourier In</option>
    <option value="7">Fourier Out</option>
</select>
<label>Impact <input type="checkbox" id="impact-input" /></label>
<br/>
<input type="file" id="file-input" />
<button id="play-btn">Play MIDI</button>
<canvas id="wave-canvas" width="200" style="display: block; border: 1px solid black;"></canvas>
<input type="text" id="fourier-values" value="0.000 0.307 0.573 0.747 0.800 0.787 0.760 0.680 0.640 0.613 0.587 0.587 0.587 0.600 0.600 0.587 0.587 0.587 0.587 0.573 0.573 0.507 0.013 -0.360 -0.387 -0.480 -0.533 -0.533 -0.533 -0.520 -0.507 -0.480 -0.467 -0.467 -0.520 -0.707 -0.760 -0.693 -0.627 -0.440 -0.267 " />
<canvas id="fourier-in" width="200" style="display: block; border: 1px solid black;"></canvas>
<p id="fourier-coef"></p>
<canvas id="fourier-out" width="200" style="display: block; border: 1px solid black;"></canvas>
<script src="midi.js"></script>
<script src="sample.mid.js"></script>
<script>

const concertPitch = 440; // Note 49, A4, 440 Hz
const concertPitchNum = 48; // (0 index)
const sharps = [false, true, false, false, true, false, true, false, false, true, false, true];
const noteRatio = Math.exp(Math.LN2 / 12);

const keysDiv = document.getElementById('keys');
for (let i = 0; i < 96; i++) {
    const btn = document.createElement('button');
    const num = i;
    btn.innerText = getNoteName(num);
    btn.addEventListener('mousedown', function (e){
        noteOn(num);
    });
    btn.addEventListener('mouseup', function (e){
        noteOff(num);
    });
    btn.addEventListener('mouseleave', function (e){
        noteOff(num);
    });
    keysDiv.appendChild(btn);

    if(num % 12 == 11) {
        keysDiv.appendChild(document.createElement('br'));
    }
}

function getNoteFreq (num) {
    return concertPitch * Math.pow(noteRatio, num - concertPitchNum);
}

function getNoteName (num) {
    const mod = num % 12;
    const alpha = 'AABCCDDEFFGG'[mod];
    const sharp = sharps[mod] ? 'â™¯' : '';
    const octave = Math.floor(num/12) + ((alpha === "A" || alpha === "B") ? 0 : 1);
    return alpha + sharp + octave;
}

for(const btn of document.getElementsByClassName('play-btn')) {
}

document.getElementById('volume-input').addEventListener('change', function (e) {
	if (gainNode) {
		gainNode.gain.linearRampToValueAtTime(e.target.value, audioCtx.currentTime + 1);
	}
});

const noteMap = {};

let audioCtx, gainNode;
function initCtx () {
	audioCtx = new (window.AudioContext || window.webkitAudioContext)();
	gainNode = audioCtx.createGain();

	gainNode.gain.setValueAtTime(0.25, 0);

	gainNode.connect(audioCtx.destination);
}

function noteOn (num) {

    if (!audioCtx) {
        initCtx();
    }

    if (!noteMap[num]) {

        const select = document.getElementById('instrument-input');
        const freq = getNoteFreq(num);
        const source = createNote(audioCtx, freq, 1, parseInt(select.value, 10));

        // connect the AudioBufferSourceNode to the
        // destination so we can hear the sound
        source.connect(gainNode);

        // start the source playing
        source.start();

        noteMap[num] = source;
    }
}

function noteOff (num) {

	if (noteMap[num]) {
        noteMap[num].stop();
        noteMap[num] = null;
	}
}

const keyMap = '`1234567890-=qwertyuiop[]\\asdfghjkl;\'zxcvbnm,./';

document.addEventListener('keydown', function (e) {
    const index = e.key === "#" ? 25 : keyMap.indexOf(e.key);

    if (index < 0) {
        return;
    };

    e.preventDefault();
    noteOn(index + 23);
});

document.addEventListener('keyup', function (e) {
    const index = e.key === "#" ? 25 : keyMap.indexOf(e.key);

    if (index < 0) {
        return;
    };

    e.preventDefault();
    noteOff(index + 23);
});

document.getElementById('play-btn').addEventListener('click', function () {
	if (!audioCtx) {
		initCtx();
	}

	const fileInput = document.getElementById('file-input');
	if (fileInput.files && fileInput.files[0]) {
		var reader = new FileReader();

		reader.onload = function(e) {
			const midiNode = new MidiNode(audioCtx);
			midiNode.connect(gainNode);
			midiNode.openFile(e.target.result);
			midiNode.start();
		}

		reader.readAsArrayBuffer(fileInput.files[0]);
	}
	else {
		const midiNode = new MidiNode(audioCtx);
		midiNode.connect(gainNode);
		midiNode.openFile(sample);
		midiNode.start();
	}

});

const instruments = {
    sine (freq) {
        const source = audioCtx.createOscillator();
        source.frequency.setValueAtTime(freq, 0);
        source.type = "sine";

        drawWave(fourier([0,1]));

        return source;
    },
    square (freq) {
        const source = audioCtx.createOscillator();
        source.frequency.setValueAtTime(freq, 0);
        source.type = "square";

        return source;
    },
    sawtooth (freq) {
        const source = audioCtx.createOscillator();
        source.frequency.setValueAtTime(freq, 0);
        source.type = "sawtooth";

        return source;
    },
    periodic (freq) {
        const source = audioCtx.createOscillator();
        source.frequency.setValueAtTime(freq, 0);
        const real = new Float32Array(6);
        const imag = new Float32Array(6);

        real[0] = 0;
        imag[0] = 0;
        real[1] = 0;
        imag[1] = 131;
        real[2] = 0;
        imag[2] = 27;
        real[3] = 0;
        imag[3] = 37;
        real[4] = 0;
        imag[4] = 14;
        real[5] = 0;
        imag[5] = 10;

        const fFn = fourier(imag.map(x=> x/131));
        drawWave(fFn);

        const wave = audioCtx.createPeriodicWave(real, imag);

        source.setPeriodicWave(wave);

        return source;
    },
    piano (freq) {
        var waveFn = fourier([0, 1, 0, 0.5]);
        drawWave(waveFn);

        const sampleCount = audioCtx.sampleRate / freq;
        const wave = waveFn(sampleCount);

        const myArrayBuffer = generateArrayBuffer(audioCtx, wave, sampleCount);

        // Get an AudioBufferSourceNode.
        // This is the AudioNode to use when we want to play an AudioBuffer
        const source = audioCtx.createBufferSource();

        // set the buffer in the AudioBufferSourceNode
        source.buffer = myArrayBuffer;

        source.loop = true;
        source.loopLength = 1 / freq;

        return source;
    },
    organ (freq) {
        var waveFn = fourier([0, 1, 0, 0.2, 0, 0.04, 0, 0.08]);
        drawWave(waveFn);

        const sampleCount = audioCtx.sampleRate / freq;
        const wave = waveFn(sampleCount);

        const myArrayBuffer = generateArrayBuffer(audioCtx, wave, sampleCount);

        // Get an AudioBufferSourceNode.
        // This is the AudioNode to use when we want to play an AudioBuffer
        const source = audioCtx.createBufferSource();

        // set the buffer in the AudioBufferSourceNode
        source.buffer = myArrayBuffer;

        source.loop = true;
        source.loopLength = 1 / freq;

        return source;
    },
    fourierIn (freq) {
        const duration = 1;
        const sampleCount = duration * audioCtx.sampleRate;
        const samplesPerCycle = Math.floor(audioCtx.sampleRate / freq);

        const values = fourierValues.value.split(" ").map(x => parseFloat(x, 10)).filter(x => isFinite(x));

        var myArrayBuffer = audioCtx.createBuffer(2, sampleCount, audioCtx.sampleRate);

        for (var channel = 0; channel < myArrayBuffer.numberOfChannels; channel++) {
        // This gives us the actual array that contains the data
            var nowBuffering = myArrayBuffer.getChannelData(channel);
            for (var i = 0; i < myArrayBuffer.length; i++) {
                const sampleNo = (i%samplesPerCycle);
                const frac = (sampleNo / samplesPerCycle) * values.length;
                const idx = Math.floor(frac);
                const delta = frac - idx;
                const next = idx < values.length - 1 ? values[idx+1] : values[0];
                nowBuffering[i] = (1-delta) * values[idx] + delta * next;
            }
        }

        // Get an AudioBufferSourceNode.
        // This is the AudioNode to use when we want to play an AudioBuffer
        const source = audioCtx.createBufferSource();

        // set the buffer in the AudioBufferSourceNode
        source.buffer = myArrayBuffer;

        return source;
    },
    fourierOut (freq) {
        const source = audioCtx.createOscillator();
        source.frequency.setValueAtTime(freq, 0);

        const wave = audioCtx.createPeriodicWave(Xk_re, Xk_im);

        source.setPeriodicWave(wave);

        return source;
    },
}

/**
 * @param {AudioContext} audioCtx
 * @param {AudioScheduledSourceNode} source
 * @param {number} gain
 * @return {AudioScheduledSourceNode}
 */
function rampOnOff (audioCtx, source, gain) {
    const gainNode = audioCtx.createGain();
    gainNode.gain.setValueAtTime(0, 0);

    source.connect(gainNode);
    return {
        connect: gainNode.connect.bind(gainNode),
        start: (when = audioCtx.currentTime) => {
            source.start(when);
            gainNode.gain.linearRampToValueAtTime(gain, when + 0.1);
        },
        stop: (when = audioCtx.currentTime) => {
            source.stop(when + 0.1);
            gainNode.gain.linearRampToValueAtTime(0, when + 0.1);
        },
    };
}

/**
 * @param {AudioContext} audioCtx
 * @param {AudioScheduledSourceNode} source
 * @param {number} gain
 * @param {number} duration
 * @return {AudioScheduledSourceNode}
 */
function impactNote (audioCtx, source, gain, duration = 1) {

    const fadeNode = audioCtx.createGain();
    fadeNode.gain.setValueAtTime(gain, 0);

    source.connect(fadeNode);

    return {
        connect: fadeNode.connect.bind(fadeNode),
        start: (when = audioCtx.currentTime) => {
            source.start(when);
            fadeNode.gain.exponentialRampToValueAtTime(0.01, when + duration);
            source.stop(when + duration);
        },
        stop: () => {},
    };
}

function createNote (audioCtx, freq, gain, program) {
    let source;
    switch (program % 8) {
		case 0: // Sine
            source = instruments.sine(freq);
            break;
        case 1: // Square
            source = instruments.square(freq);
            break;
        case 2: // Sawtooth
            source = instruments.sawtooth(freq);
            break;
        case 3: // Periodic
            source = instruments.periodic(freq);
            break;
		case 4: // Organ
            source = instruments.organ(freq);
            break;
		case 5: // Piano
            source = instruments.piano(freq);
            break;
		case 6: // Fourier In
            source = instruments.fourierIn(freq);
            break;
		case 7: // Fourier Out
            source = instruments.fourierOut(freq);
            break;
        default:
            throw Error("No program (instrument) selected");
    }

    return document.getElementById("impact-input").checked ?
            impactNote(audioCtx, source, gain) :
            rampOnOff(audioCtx, source, gain);
}

function fourier (coef) {
	const coefSum = coef.reduce((a,b) => a+b, 0);
	if (coefSum === 0) {
		throw Error("You must supply some coefficients");
	}
	return function (sampleCount) {
		return function (i) {
			return coef.map((c,n) => (c / coefSum) * Math.sin(i * n / sampleCount * Math.PI * 2)).reduce((a,b) => a+b, 0);
		}
	}
}

function generateArrayBuffer(audioCtx, wave, sampleCount) {

    // Create an empty stereo buffer at the sample rate of the AudioContext
    var myArrayBuffer = audioCtx.createBuffer(2, sampleCount, audioCtx.sampleRate);

    for (var channel = 0; channel < myArrayBuffer.numberOfChannels; channel++) {
      // This gives us the actual array that contains the data
      var nowBuffering = myArrayBuffer.getChannelData(channel);
      for (var i = 0; i < myArrayBuffer.length; i++) {
        nowBuffering[i] = wave(i);
      }
    }

    return myArrayBuffer;
}

function drawWave (waveFn) {
    const canvas = document.getElementById('wave-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);

    const wave = waveFn(canvas.width);
    for(var i = 0; i < canvas.width; i++) {
        ctx.lineTo(i, (-wave(i) + 1) * canvas.height / 2);
    }
    ctx.stroke();
}

let Xk_re, Xk_im;
const fourierValues = document.getElementById('fourier-values');
const canvas = document.getElementById('fourier-in');
fourierValues.addEventListener("change", doFourier);
doFourier();

canvas.addEventListener("click", function (e) {
    const x = e.offsetX / e.target.width;
    const y = 1 - (e.offsetY / e.target.height) * 2;
    const values = fourierValues.value.split(" ").map(x => parseFloat(x, 10)).filter(x => isFinite(x));
    const X = Math.floor((x * (values.length - 1)) + 0.5);
    values[X] = y;
    fourierValues.value = values.map(x => x.toFixed(3)).join(" ");
    doFourier();
});

function doFourier () {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const values = fourierValues.value.split(" ").map(x => parseFloat(x, 10)).filter(x => isFinite(x));

    ctx.beginPath();
    ctx.strokeStyle = "#CCCCCC";
    for(var i = 0; i < values.length -1; i++) {
        ctx.moveTo(((i+0.5) / (values.length - 1)) * canvas.width, 0);
        ctx.lineTo(((i+0.5) / (values.length - 1)) * canvas.width, canvas.height);
    }
    ctx.stroke();

    ctx.beginPath();
    for(var i = 0; i < values.length; i++) {
        ctx.lineTo(i * canvas.width / (values.length - 1), (-values[i] + 1) * canvas.height / 2);
    }
    ctx.stroke();

    ctx.fillStyle = "#0080FF";
    for(var i = 0; i < values.length; i++) {
        ctx.beginPath();
        ctx.arc(i * canvas.width / (values.length - 1), (-values[i] + 1) * canvas.height / 2, 2, 0, Math.PI*2, true);
        ctx.fill();
    }

    // DCT-II
    // X_k = #Sigma^N-1_n=0 {x_n * [ cos(#pi / N * (n + 0.5) * k) ]}
    const N = values.length;
    // let Xk = values.map((_,k) => Math.sqrt(2/N) * values.map((xn,n) => xn * Math.cos(Math.PI / N * k * (n + 0.5)) ).reduce((a,b) => a+b, 0) );
    // Xk[0] *= Math.SQRT1_2;
    // Xk = [0,1];
    // console.log(Xk);

    const range = n => [...Array(n).keys()];

    // Fourier
    // n.b. Wiki says inverse is 1/N but for some reason that results in range -0.5 to 0.5
    Xk_re = Float32Array.from(range(N-1).map(k => 2/N * values.map((xn,n) => xn * Math.cos(2 * Math.PI * k * n / N) ).reduce((a,b) => a+b, 0) ));
    Xk_im = Float32Array.from(range(N-1).map(k => 2/N * values.map((xn,n) => xn * Math.sin(2 * Math.PI * k * n / N) ).reduce((a,b) => a+b, 0) ));

    // x=0 to x=N-1???
    Xk_re.length -= 1;
    Xk_im.length -= 1;

    document.getElementById("fourier-coef").innerHTML = Xk_re.map(x => x.toFixed(2)).join() + "<br>" + Xk_im.map(x => x.toFixed(2)).join();

    const canvas2 = document.getElementById('fourier-out');
    const ctx2 = canvas2.getContext('2d');
    ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

    ctx2.beginPath();

    for(var i = 0; i < canvas2.width; i++) {
        const x = i / canvas2.width * Math.PI * 2;
        const value = Xk_re.map((X_k, k) => X_k * Math.cos(x * k)).reduce((a,b) => a+b) + Xk_im.map((X_k, k) => X_k * Math.sin(x * k)).reduce((a,b) => a+b);
        ctx2.lineTo(i, (-value + 1) * canvas2.height / 2);
    }
    ctx2.stroke();
}
</script>
</body>
</html>

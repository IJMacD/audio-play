<html>
<head>
<title>AudioPlay</title>
</head>
<body>
<div id="keys"></div>
<br>
<input type="range" min="0" max="1" step="0.05" value="0.25" id="volume-input" />
<select id="instrument-input">
    <option value="0">Sine</option>
    <option value="1">Square</option>
    <option value="2">Periodic</option>
    <option value="3">Organ</option>
    <option value="4">Piano</option>
</select>
<br/>
<input type="file" id="file-input" />
<button id="play-btn">Play MIDI</button>
<canvas id="wave-canvas" width="200" style="display: block; border: 1px solid black;"></canvas>
<input type="text" id="fourier-values" value="0.9431 0.5606 -0.0415 -0.6273 -0.9674 -0.9285 -0.5258 0 0.5944 0.9561" />
<canvas id="fourier-in" width="200" style="display: block; border: 1px solid black;"></canvas>
<canvas id="fourier-out" width="200" style="display: block; border: 1px solid black;"></canvas>
<script src="midi.js"></script>
<script src="sample.mid.js"></script>
<script>

const concertPitch = 440; // Note 49, A4, 440 Hz
const concertPitchNum = 48; // (0 index)
const sharps = [false, true, false, false, true, false, true, false, false, true, false, true];
const noteRatio = Math.exp(Math.LN2 / 12);

const keysDiv = document.getElementById('keys');
for (let i = 0; i < 96; i++) {
    const btn = document.createElement('button');
    const num = i;
    btn.innerText = getNoteName(num);
    btn.addEventListener('click', function (e){
        playNote(getNoteFreq(num));
        console.log(getNoteName(num));
    });
    keysDiv.appendChild(btn);

    if(num % 12 == 11) {
        keysDiv.appendChild(document.createElement('br'));
    }
}

function getNoteFreq (num) {
    return concertPitch * Math.pow(noteRatio, num - concertPitchNum);
}

function getNoteName (num) {
    const mod = num % 12;
    const alpha = 'AABCCDDEFFGG'[mod];
    const sharp = sharps[mod] ? 'â™¯' : '';
    const octave = Math.floor(num/12) + ((alpha === "A" || alpha === "B") ? 0 : 1);
    return alpha + sharp + octave;
}

for(const btn of document.getElementsByClassName('play-btn')) {
}

document.getElementById('volume-input').addEventListener('change', function (e) {
	if (gainNode) {
		gainNode.gain.linearRampToValueAtTime(e.target.value, audioCtx.currentTime + 1);
	}
});

const noteMap = {};

let audioCtx, gainNode;
function initCtx () {
	audioCtx = new (window.AudioContext || window.webkitAudioContext)();
	gainNode = audioCtx.createGain();

	gainNode.gain.setValueAtTime(0.25, 0);

	gainNode.connect(audioCtx.destination);
}

document.addEventListener('keydown', function (e) {
    const keyMap = '1234567890-=qwertyuiop[]\\asdfghjkl;\'zxcvbnm,./ `';
    const noteNum = keyMap.indexOf(e.key) + 24;

    if (!audioCtx) {
        initCtx();
    }

    if (noteNum < 24) {
        return;
    }

    if (!noteMap[noteNum]) {

        const select = document.getElementById('instrument-input');
        const freq = getNoteFreq(noteNum);
        const source = createNote(audioCtx, freq, 1, parseInt(select.value, 10));

        // connect the AudioBufferSourceNode to the
        // destination so we can hear the sound
        source.connect(gainNode);

        // start the source playing
        source.start();

        noteMap[noteNum] = source;
    }
});

document.addEventListener('keyup', function (e) {
    const keyMap = '1234567890-=qwertyuiop[]\\asdfghjkl;\'zxcvbnm,./ `';
    const noteNum = keyMap.indexOf(e.key) + 24;

    if (noteNum < 24) {
        return;
    }

	if (noteMap[noteNum]) {
        noteMap[noteNum].stop();
        noteMap[noteNum] = null;
	}
});

document.getElementById('play-btn').addEventListener('click', function () {
	if (!audioCtx) {
		initCtx();
	}

	const fileInput = document.getElementById('file-input');
	if (fileInput.files && fileInput.files[0]) {
		var reader = new FileReader();

		reader.onload = function(e) {
			const midiNode = new MidiNode(audioCtx);
			midiNode.connect(gainNode);
			midiNode.openFile(e.target.result);
			midiNode.start();
		}

		reader.readAsArrayBuffer(fileInput.files[0]);
	}
	else {
		const midiNode = new MidiNode(audioCtx);
		midiNode.connect(gainNode);
		midiNode.openFile(sample);
		midiNode.start();
	}

});

function createNote (audioCtx, freq, gain, program) {
	let source;
	switch (program) {
		case 0:
        {
			source = audioCtx.createOscillator();
			source.frequency.setValueAtTime(freq, 0);
			source.type = "sine";

            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0, 0);

            source.connect(gainNode);
            return {
                connect: gainNode.connect.bind(gainNode),
                start: (when = audioCtx.currentTime) => {
                    source.start(when);
                    gainNode.gain.linearRampToValueAtTime(gain, when + 0.1);
                },
                stop: (when = audioCtx.currentTime) => {
                    source.stop(when + 0.1);
                    gainNode.gain.linearRampToValueAtTime(0, when + 0.1);
                },
            };
        }
		case 1:
        {
			source = audioCtx.createOscillator();
			source.frequency.setValueAtTime(freq, 0);
			source.type = "square";

            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0, 0);

            source.connect(gainNode);
            return {
                connect: gainNode.connect.bind(gainNode),
                start: (when = audioCtx.currentTime) => {
                    source.start(when);
                    gainNode.gain.linearRampToValueAtTime(gain, when + 0.1);
                },
                stop: (when = audioCtx.currentTime) => {
                    source.stop(when + 0.1);
                    gainNode.gain.linearRampToValueAtTime(0, when + 0.1);
                },
            };
        }
		case 2:
        {
			source = audioCtx.createOscillator();
			source.frequency.setValueAtTime(freq, 0);
			const real = new Float32Array(3);
			const imag = new Float32Array(3);

			real[0] = 0;
			imag[0] = 0;
			real[1] = 1;
			imag[1] = 0;
			real[2] = 0.2;
			imag[2] = 0;

			const wave = audioCtx.createPeriodicWave(real, imag);

			source.setPeriodicWave(wave);

            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0, 0);

            source.connect(gainNode);
            return {
                connect: gainNode.connect.bind(gainNode),
                start: (when = audioCtx.currentTime) => {
                    source.start(when);
                    gainNode.gain.linearRampToValueAtTime(gain, when + 0.1);
                },
                stop: (when = audioCtx.currentTime) => {
                    source.stop(when + 0.1);
                    gainNode.gain.linearRampToValueAtTime(0, when + 0.1);
                },
            };
        }
		case 3:
        {
			var waveFn = fourier([0, 1, 0, 0.5]);
            drawWave(waveFn);

            const sampleCount = audioCtx.sampleRate / freq;
            const wave = waveFn(sampleCount);

			const myArrayBuffer = generateArrayBuffer(audioCtx, wave, sampleCount);

            // Get an AudioBufferSourceNode.
            // This is the AudioNode to use when we want to play an AudioBuffer
            source = audioCtx.createBufferSource();

			// set the buffer in the AudioBufferSourceNode
			source.buffer = myArrayBuffer;

			source.loop = true;
			source.loopLength = 1 / freq;

            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0, 0);

            source.connect(gainNode);
            return {
                connect: gainNode.connect.bind(gainNode),
                start: (when = audioCtx.currentTime) => {
                    source.start(when);
                    gainNode.gain.linearRampToValueAtTime(gain, when + 0.1);
                },
                stop: (when = audioCtx.currentTime) => {
                    source.stop(when + 0.1);
                    gainNode.gain.linearRampToValueAtTime(0, when + 0.1);
                },
            };
        }
		case 4:
        {
			var waveFn = fourier([0, 1, 0, 0.2, 0, 0.04, 0, 0.08]);
            drawWave(waveFn);

            const duration = 1;
            const waveCount = Math.floor(duration * freq);
            const actualDuration = waveCount / freq;
            const sampleCount = actualDuration * audioCtx.sampleRate;
            const wave = waveFn(sampleCount / waveCount);


			const myArrayBuffer = generateArrayBuffer(audioCtx, wave, sampleCount);

			// Get an AudioBufferSourceNode.
			// This is the AudioNode to use when we want to play an AudioBuffer
			source = audioCtx.createBufferSource();

			// set the buffer in the AudioBufferSourceNode
			source.buffer = myArrayBuffer;

            const fadeNode = audioCtx.createGain();
            fadeNode.gain.setValueAtTime(1, 0);

            source.connect(fadeNode);

            return {
                connect: fadeNode.connect.bind(fadeNode),
                start: (when = audioCtx.currentTime) => {
                    source.start(when);
                    fadeNode.gain.linearRampToValueAtTime(0.01, when + 1);
                    source.stop(when + 1);
                },
                stop: () => {},
            };
        }
        default:
            throw Error("No program (instrument) selected");
	}
}

function fourier (coef) {
	const coefSum = coef.reduce((a,b) => a+b, 0);
	if (coefSum === 0) {
		throw Error("You must supply some coefficients");
	}
	return function (sampleCount) {
		return function (i) {
			return coef.map((c,n) => (c / coefSum) * Math.sin(i * n / sampleCount * Math.PI * 2)).reduce((a,b) => a+b, 0);
		}
	}
}

function generateArrayBuffer(audioCtx, wave, sampleCount) {

    // Create an empty stereo buffer at the sample rate of the AudioContext
    var myArrayBuffer = audioCtx.createBuffer(2, sampleCount, audioCtx.sampleRate);

    for (var channel = 0; channel < myArrayBuffer.numberOfChannels; channel++) {
      // This gives us the actual array that contains the data
      var nowBuffering = myArrayBuffer.getChannelData(channel);
      for (var i = 0; i < myArrayBuffer.length; i++) {
        nowBuffering[i] = wave(i);
      }
    }

    return myArrayBuffer;
}

function drawWave (waveFn) {
    const canvas = document.getElementById('wave-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);

    const wave = waveFn(canvas.width);
    for(var i = 0; i < canvas.width; i++) {
        ctx.lineTo(i, (-wave(i) + 1) * canvas.height / 2);
    }
    ctx.stroke();
}

const fourierValues = document.getElementById('fourier-values');
const canvas = document.getElementById('fourier-in');
const ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, canvas.width, canvas.height);

ctx.beginPath();
ctx.moveTo(0, canvas.height / 2);

const values = fourierValues.value.split(" ");
for(var i = 0; i < values.length; i++) {
	ctx.lineTo(i * canvas.width / (values.length - 1), (-values[i] + 1) * canvas.height / 2);
}
ctx.stroke();

// DCT-II
// X_k = #Sigma^N-1_n=0 {x_n * [ cos(#pi / N * (n + 0.5) * k) ]}
const N = values.length;
const Xk = values.map((_,k) => values.map((xn,n) => xn * Math.cos(Math.PI / N * k * (n + 0.5)) ).reduce((a,b) => a+b, 0) )
console.log(Xk);

const canvas2 = document.getElementById('fourier-out');
const ctx2 = canvas2.getContext('2d');
ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

ctx2.beginPath();
ctx2.moveTo(0, canvas2.height / 2);

for(var i = 0; i < canvas2.width; i++) {
	const x = i / canvas2.width * Math.PI * 2;
	const value = Xk[0] + Xk[1] * Math.cos(x);// + Xk[2] * Math.cos(x / 2) +  Xk[3] * Math.cos(x / 3);
	ctx2.lineTo(i, (-value + 1) * canvas2.height / 2);
}
ctx2.stroke();
</script>
</body>
</html>

<html>
<head>
<meta charset="utf-8" />
<title>AudioPlay</title>
<style>
#keys {
    overflow-x: auto;
    white-space: nowrap;
    position: relative;
}
.key {
    height: 100px;
    width: 25px;
    background-color: white;
    border: 1px solid #999;
    border-radius: 3px;
    font-size: small;
    padding: 0;
}
.key.sharp {
    background-color: black;
    color: white;
    height: 33px;
    position: absolute;
    margin-left: -12.5px;
}
#fourier-coef {
    overflow: hidden;
}
</style>
</head>
<body>
<div id="keys"></div>
<br>
<input type="range" min="0" max="1" step="0.05" value="0.25" id="volume-input" />
<input type="number" id="instrument-input" min="0" max="15" value="0" />
<ol start="0">
    <li value="0">Sine</li>
    <li value="1">Square</li>
    <li value="2">Sawtooth</li>
    <li value="3">Periodic</li>
    <li value="4">Organ</li>
    <li value="5">Piano</li>
    <li value="6">Fourier In</li>
    <li value="7">Fourier Out</li>
</ol>
<br/>
<input type="file" id="file-input" />
<button id="play-btn">Play MIDI</button>
<canvas id="scope-canvas" width="256" style="display: block; border: 1px solid black;"></canvas>
<canvas id="freq-canvas" width="256" style="display: block; border: 1px solid black;"></canvas>
<canvas id="wave-canvas" width="200" style="display: block; border: 1px solid black;"></canvas>
<input type="text" id="fourier-values" value="0.000 0.307 0.573 0.747 0.800 0.787 0.760 0.680 0.640 0.613 0.587 0.587 0.587 0.600 0.600 0.587 0.587 0.587 0.587 0.573 0.573 0.507 0.013 -0.360 -0.387 -0.480 -0.533 -0.533 -0.533 -0.520 -0.507 -0.480 -0.467 -0.467 -0.520 -0.707 -0.760 -0.693 -0.627 -0.440 -0.267 " />
<canvas id="fourier-in" width="200" style="display: block; border: 1px solid black;"></canvas>
<p id="fourier-coef"></p>
<canvas id="fourier-out" width="200" style="display: block; border: 1px solid black;"></canvas>
<script src="midi.js"></script>
<script src="synth.js"></script>
<script src="sample.mid.js"></script>
<script>
"use strict";

const keysDiv = document.getElementById('keys');
for (let i = 0; i < 96; i++) {
    const btn = document.createElement('button');
    const num = i;
    btn.innerText = synth.getNoteName(num);
    btn.className = synth.isSharp(num) ? "key sharp" : "key";
    btn.addEventListener('mousedown', function (e){
        const select = document.getElementById('instrument-input');
        const program = parseInt(select.value, 10)
        synth.noteOn(program, num);
    });
    btn.addEventListener('mouseup', function (e){
        synth.noteOff(num);
    });
    btn.addEventListener('mouseleave', function (e){
        synth.noteOff(num);
    });
    keysDiv.appendChild(btn);
}

document.getElementById('volume-input').addEventListener('change', function (e) {
	synth.setVolume(e.target.value, synth.currentTime + 1);
});

synth.addAnalyser(function (analyser) {

    const timeCanvas = document.getElementById("scope-canvas");
    const tCtx = timeCanvas.getContext("2d");

    const freqCanvas = document.getElementById("freq-canvas");
    const fCtx = freqCanvas.getContext("2d");

    const count = 1024;
    analyser.fftSize = count;
    const buffer = new Float32Array(analyser.frequencyBinCount);

    scope();

    function scope() {
        requestAnimationFrame(scope);

        analyser.getFloatTimeDomainData(buffer);

        tCtx.clearRect(0, 0, timeCanvas.width, timeCanvas.height);

        tCtx.beginPath();

        for(let i = 0; i < buffer.length; i++) {
            const y = (1-buffer[i]) * timeCanvas.height / 2;
            if (i === 0) {
                tCtx.moveTo(0, y);
            } else
            {
                tCtx.lineTo(i / buffer.length * timeCanvas.width, y);
            }
        }
        tCtx.stroke();

        analyser.getFloatFrequencyData(buffer);

        fCtx.clearRect(0, 0, freqCanvas.width, freqCanvas.height);

        fCtx.beginPath();

        const usefulBucketCount = buffer.length / 4;
        for(let i = 0; i < usefulBucketCount; i++) {
            const y = (1-buffer[i]) * 0.01 * freqCanvas.height / 2;
            if (i === 0) {
                fCtx.moveTo(0, y);
            } else
            {
                fCtx.lineTo(i / (usefulBucketCount - 1) * freqCanvas.width, y);
            }
        }
        fCtx.stroke();
    }
})

const keyMap = '`1234567890-=qwertyuiop[]\\asdfghjkl;\'zxcvbnm,./';
const dvorakMap = '1234567890[]\',.pyfgcrl/=aoeuidhtns-\\\\;qjkxbmwvz';

document.addEventListener('keydown', function (e) {
    if (e.key === "ArrowUp") {
        const instrument = document.getElementById('instrument-input');
        instrument.value = parseInt(instrument.value, 10) + 1;
        e.preventDefault();
    } else if (e.key === "ArrowDown") {
        const instrument = document.getElementById('instrument-input');
        instrument.value = parseInt(instrument.value, 10) - 1;
        e.preventDefault();
    }
    else if(e.target.type !== "text" && e.target.type !== "number") {
        const index = e.key === "#" ? 25 : keyMap.indexOf(e.key);

        if (index < 0) {
            return;
        };

        const select = document.getElementById('instrument-input');
        const program = parseInt(select.value, 10)

        e.preventDefault();
        synth.noteOn(program, index + 23);
    }
});

document.addEventListener('keyup', function (e) {
    const index = e.key === "#" ? 25 : keyMap.indexOf(e.key);

    if (index < 0) {
        return;
    };

    e.preventDefault();
    synth.noteOff(index + 23);
});

document.getElementById('play-btn').addEventListener('click', function () {

	const fileInput = document.getElementById('file-input');
	if (fileInput.files && fileInput.files[0]) {
		var reader = new FileReader();

		reader.onload = function(e) {
			const midiNode = new MidiNode(synth);
			midiNode.connect(gainNode);
			midiNode.openFile(e.target.result);
			midiNode.start();
		}

		reader.readAsArrayBuffer(fileInput.files[0]);
	}
	else {
		const midiNode = new MidiNode(synth);
		midiNode.connect(gainNode);
		midiNode.openFile(sample);
		midiNode.start();
	}

});

function drawWave (waveFn) {
    const canvas = document.getElementById('wave-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);

    const wave = waveFn(canvas.width);
    for(var i = 0; i < canvas.width; i++) {
        ctx.lineTo(i, (-wave(i) + 1) * canvas.height / 2);
    }
    ctx.stroke();
}

let Xk_re, Xk_im;
const fourierValues = document.getElementById('fourier-values');
const canvas = document.getElementById('fourier-in');
fourierValues.addEventListener("change", doFourier);
doFourier();

canvas.addEventListener("click", handleFourierInput);

canvas.addEventListener("mousemove", function (e) {
    if (e.which === 1) {
        handleFourierInput(e);
    }
});

function handleFourierInput (e) {
    const x = e.offsetX / e.target.width;
    const y = 1 - (e.offsetY / e.target.height) * 2;
    const values = fourierValues.value.split(" ").map(x => parseFloat(x, 10)).filter(x => isFinite(x));
    const X = Math.floor((x * (values.length - 1)) + 0.5);
    values[X] = y;
    fourierValues.value = values.map(x => x.toFixed(3)).join(" ");
    doFourier();
}

function doFourier () {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const values = fourierValues.value.split(" ").map(x => parseFloat(x, 10)).filter(x => isFinite(x));

    ctx.beginPath();
    ctx.strokeStyle = "#CCCCCC";
    for(var i = 0; i < values.length -1; i++) {
        ctx.moveTo(((i+0.5) / (values.length - 1)) * canvas.width, 0);
        ctx.lineTo(((i+0.5) / (values.length - 1)) * canvas.width, canvas.height);
    }
    ctx.stroke();

    ctx.beginPath();
    for(var i = 0; i < values.length; i++) {
        ctx.lineTo(i * canvas.width / (values.length - 1), (-values[i] + 1) * canvas.height / 2);
    }
    ctx.stroke();

    ctx.fillStyle = "#0080FF";
    for(var i = 0; i < values.length; i++) {
        ctx.beginPath();
        ctx.arc(i * canvas.width / (values.length - 1), (-values[i] + 1) * canvas.height / 2, 2, 0, Math.PI*2, true);
        ctx.fill();
    }

    // DCT-II
    // X_k = #Sigma^N-1_n=0 {x_n * [ cos(#pi / N * (n + 0.5) * k) ]}
    const N = values.length;
    // let Xk = values.map((_,k) => Math.sqrt(2/N) * values.map((xn,n) => xn * Math.cos(Math.PI / N * k * (n + 0.5)) ).reduce((a,b) => a+b, 0) );
    // Xk[0] *= Math.SQRT1_2;
    // Xk = [0,1];
    // console.log(Xk);

    const range = n => [...Array(n).keys()];

    // Fourier
    // n.b. Wiki says inverse is 1/N but for some reason that results in range -0.5 to 0.5
    Xk_re = Float32Array.from(range(N-1).map(k => 2/N * values.map((xn,n) => xn * Math.cos(2 * Math.PI * k * n / N) ).reduce((a,b) => a+b, 0) ));
    Xk_im = Float32Array.from(range(N-1).map(k => 2/N * values.map((xn,n) => xn * Math.sin(2 * Math.PI * k * n / N) ).reduce((a,b) => a+b, 0) ));


    document.getElementById("fourier-coef").innerHTML = Xk_re.map(x => x.toFixed(2)).join() + "<br>" + Xk_im.map(x => x.toFixed(2)).join();

    const canvas2 = document.getElementById('fourier-out');
    const ctx2 = canvas2.getContext('2d');
    ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

    ctx2.beginPath();

    for(var i = 0; i < canvas2.width; i++) {
        const x = i / canvas2.width * Math.PI * 2;
        const value = Xk_re.map((X_k, k) => X_k * Math.cos(x * k)).reduce((a,b) => a+b) + Xk_im.map((X_k, k) => X_k * Math.sin(x * k)).reduce((a,b) => a+b);
        ctx2.lineTo(i, (-value + 1) * canvas2.height / 2);
    }
    ctx2.stroke();
}
</script>
</body>
</html>
